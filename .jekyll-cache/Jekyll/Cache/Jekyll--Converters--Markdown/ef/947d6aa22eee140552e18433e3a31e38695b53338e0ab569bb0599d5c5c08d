I"v<h3 id="the-complete-code-for-k-means-in-r">The Complete Code for K-means in R</h3>

<p>K-Means algorithm from kmeans_mehdi.R</p>

<pre><code class="language-{r}">library(ggplot2)

x &lt;- round(rnorm(1000,100,15)) + rnorm(1000)*15

dens.x   &lt;- density(x)
empir.df &lt;- data.frame(type='empir', x=dens.x$x, density=dens.x$y)
norm.df  &lt;- data.frame(type='normal', x=50:150, density=dnorm (50:150,100,15))
df       &lt;- rbind(empir.df, norm.df)
m        &lt;- ggplot(data = df, aes(x,density))
m + geom_line(aes(linetype=type, colour=type))




k = 3            # the number of K's
max = 5000       # the maximum number for generating random points
n = 100          # the number of points
maxIter = 10     # maximum number of iterations
threshold = 0.1  # difference of old means and new means

# Randomly generate points in the form of (x,y)
x &lt;- sample(1:max, n)
y &lt;- sample(1:max, n)

# Put point into a matrix
z &lt;- c(x,y)
m = matrix(z, ncol=2)

ks &lt;- c(1, 2, 4, 8, 10, 15, 20)  # Different Ks
for(k in ks) {
   myKmeans(m, k, max)
}

# Initialization for k means: the k-first points in the list
myKmeans &lt;- function(m, k, max) {
  x &lt;- m[, 1]
  y &lt;- m[, 2]
  d=matrix(data=NA, ncol=0, nrow=0)
  for(i in 1:k) {
    d &lt;- c(d, c(x[i], y[i]))
}

init &lt;- matrix(d, ncol=2, byrow=TRUE)

dev.new()
plotTitle &lt;- paste("K-Means Clustering K = ", k)
plot(m, xlim=c(1,max), ylim=c(1,max), xlab="X", ylab="Y", pch=20, main="plotTitle")
par(new=T)
plot(init, pch=2, xlim=c(1,max), ylim=c(1,max), xlab="X", ylab="Y")
par(new=T)

oldMeans &lt;- init
oldMeans

cl &lt;- Clustering(m, oldMeans)
cl

means &lt;- UpdateMeans(m, cl, k)

thr &lt;- delta(oldMeans, means)
itr &lt;- 1
while(thr &gt; threshold){
  cl       &lt;- Clustering(m, means)
  oldMeans &lt;- means
  means    &lt;- UpdateMeans(m, cl, k)
  thr      &lt;- delta(oldMeans, means)
  itr      &lt;- itr+1
}

cl
thr
means
itr

for(km in 1:k) {
  group &lt;- which(cl == km)
  plot(m[group,],axes=F, col=km, xlim=c(1,max), ylim=c(1,max), pch=20, xlab="X", ylab="Y")
  par(new=T)
}

plot(means, axes=F, pch=8, col=15, xlim=c(1,max), ylim=c(1,max), xlab="X", ylab="Y")
par(new=T)

dev.off()
} # end function myKmeans

# function distance
dist &lt;- function(x,y) {
	d&lt;-sqrt( sum((x - y) **2 ))
}

createMeanMatrix &lt;- function(d) {
	matrix(d, ncol=2, byrow=TRUE)
}

# Compute Euclidean Distances
euclid &lt;- function(a,b) {
  d &lt;-sqrt(a**2 + b**2)
}

euclid2 &lt;- function(a) {
  d &lt;-sqrt(sum(a**2))
}

# compute difference between new means and old means
delta &lt;- function(oldMeans, newMeans) {
  a &lt;- newMeans - oldMeans
  max(euclid(a[, 1], a[, 2]))
}

Clustering &lt;- function(m, means) {
  clusters = c()
  n &lt;- nrow(m)
  for(i in 1:n) {
    distances = c()
    k &lt;- nrow(means)
    for(j in 1:k) {
	  di &lt;- m[i,] - means[j,]
	  ds &lt;- euclid2(di)
	  distances &lt;- c(distances, ds)
    }
    minDist &lt;- min(distances)
    cl &lt;- match(minDist, distances)
    clusters &lt;- c(clusters, cl)    
  }
  return (clusters)
}

UpdateMeans &lt;- function(m, cl, k) {
  means &lt;- c()
  for(c in 1:k) {
    # get the point of cluster c
    group &lt;- which(cl == c)
    
    # compute the mean point of all points in cluster c
    mt1 &lt;- mean(m[group,1])
    mt2 &lt;- mean(m[group,2])
    vMean &lt;- c(mt1, mt2)
    means &lt;- c(means, vMean)
   }
  means &lt;- createMeanMatrix(means)
  return(means)
}
</code></pre>

:ET